#version 460 core
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_shader_clock : enable

#include "shader_utils.glsl"
#include "random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT top_level_AS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraMatrices {
    mat4 view;
    mat4 proj;
    mat4 view_inverse;
    mat4 proj_inverse;
    int frame;
} cam;

layout(location = 0) rayPayloadEXT HitPayload payload;

void main() {

    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));
    float r1 = rnd(seed);
    float r2 = rnd(seed);
    vec2 subpixel_jitter = cam.frame == 0 ? vec2(0.5,0.5) : vec2(r1, r2);

    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
    const vec2 uv = pixel_center/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = uv * 2.0 - 1.0;

    payload.ray_origin = (cam.view_inverse * vec4(0,0,0,1)).xyz;
    vec4 target = cam.proj_inverse * vec4(d.x, d.y, 1,1);
    payload.ray_direction = (cam.view_inverse * vec4(normalize(target.xyz), 0)).xyz;

    uint ray_flags = gl_RayFlagsOpaqueEXT;
    uint mask = 0xff;
    float t_min = 0.001;
    float t_max = 10000.0;

    payload.direct_color = vec3(0);
    payload.depth = 0;
    payload.seed = seed;
    payload.weight = vec3(0);

    vec3 weight = vec3(1);
    vec3 color = vec3(0);

    for (; payload.depth < 16; payload.depth ++) {
        traceRayEXT(top_level_AS, ray_flags, mask, 0, 0, 0, payload.ray_origin, t_min, payload.ray_direction, t_max, 0);
        color += payload.direct_color * weight;
        weight *= payload.weight;
    }
    
    if(cam.frame > 0) {
        float a = 1.0 / float(cam.frame + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color,color,a), 1.0));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
    }

    
}
