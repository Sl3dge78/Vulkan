#version 460 core
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_shader_clock : enable

#include "shader_utils.glsl"
#include "random.glsl"

//  void traceRayEXT(accelerationStructureEXT topLevel,
//                    uint rayFlags,
//                    uint cullMask,
//                    uint sbtRecordOffset,
//                    uint sbtRecordStride,
//                    uint missIndex,
//                    vec3 origin,
//                    float Tmin,
//                    vec3 direction,
//                    float Tmax,
//                    int payload);

layout(binding = 0, set = 0, rgba8) uniform image2D image;
layout(binding = 1, set = 0) uniform accelerationStructureEXT top_level_AS;
layout(binding = 2, set = 0) uniform CameraMatrices {
    mat4 view;
    mat4 proj;
    mat4 view_inverse;
    mat4 proj_inverse;
    vec3 pos;
    int frame;
} cam;

layout(location = 0) rayPayloadEXT HitPayloadSimple payload;


void main() {

    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));
    float r1 = rnd(seed);
    float r2 = rnd(seed);
    vec2 subpixel_jitter = cam.frame == 0 ? vec2(0.5,0.5) : vec2(r1, r2);

    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
    const vec2 uv = pixel_center/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = uv * 2.0 - 1.0;

    payload.ray_origin = (cam.view_inverse * vec4(0,0,0,1)).xyz;
    vec4 target = cam.proj_inverse * vec4(d.x, d.y, 1,1);
    payload.ray_dir = (cam.view_inverse * vec4(normalize(target.xyz), 0)).xyz;

    uint ray_flags = gl_RayFlagsOpaqueEXT;
    uint mask = 0xff;
    float t_min = 0.00;
    float t_max = STEP_DIST; // Density
    payload.direct_color = vec3(0);
    payload.vol_col = vec3(0.0);
    payload.vol_abs = vec3(1.0);
    for(payload.depth = 0; payload.depth < 32; payload.depth++) {
        payload.pos = payload.ray_origin + payload.ray_dir * t_max;
        traceRayEXT(top_level_AS, ray_flags, mask, 0, 0, 0, payload.ray_origin, t_min, payload.ray_dir, t_max, 0);
        payload.ray_origin += payload.ray_dir * t_max;
    }
    vec3 color = payload.direct_color * payload.vol_abs + payload.vol_col;

    
    if(cam.frame > 0) {
        float a = 1.0 / float(cam.frame + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color,color,a), 1.0));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
    }
}

/*
void main() {

    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));
    float r1 = rnd(seed);
    float r2 = rnd(seed);
    vec2 subpixel_jitter = cam.frame == 0 ? vec2(0.5,0.5) : vec2(r1, r2);

    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
    const vec2 uv = pixel_center/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = uv * 2.0 - 1.0;

    vec3 ray_origin = (cam.view_inverse * vec4(0,0,0,1)).xyz;
    vec4 target = cam.proj_inverse * vec4(d.x, d.y, 1,1);
    vec3 ray_direction = (cam.view_inverse * vec4(normalize(target.xyz), 0)).xyz;

    uint ray_flags = gl_RayFlagsOpaqueEXT;
    uint mask = 0xff;
    float t_min = 0.001;
    float t_max = 10000.0;

    payload.direct_color = vec3(0);
    traceRayEXT(top_level_AS, ray_flags, mask, 0, 0, 0, ray_origin, t_min, ray_direction, t_max, 0);
    vec3 color = payload.direct_color;

    if(cam.frame > 0) {
        float a = 1.0 / float(cam.frame + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color,color,a), 1.0));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
    }
}
*/
